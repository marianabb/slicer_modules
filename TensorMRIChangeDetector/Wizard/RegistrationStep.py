from __main__ import qt, ctk, vtk, slicer

from TMRIChangeDetectorStep import *


class RegistrationStep(TMRIChangeDetectorStep):
  def __init__(self, stepid):
    self.initialize(stepid)
    self.setName( '2. Set up BRAINS Demon registration' )
    self.setDescription( 'Set up the important attributes of the registration method or select an already existent deformation field.' )
    
    self.__parent = super(RegistrationStep, self)

    # Define a clean GroupBox for specific registration method settings
    self.__regGroupBox = None
    
    # Transform generated by the registration to go from the follow-up to the baseline volume
    self.__registeredTransform = None
    # Volume generated by the registration (follow-up volume registered to baseline volume)
    self.__registeredVolume = None

    qt.QTimer.singleShot(0, self.killButton)


  def createUserInterface(self):
    '''
    The interface allows choosing a registration method and applying it on the already chosen volumes.
    Alternatively the user can choose an already registered volume.
    '''

    self.__layout = self.__parent.createUserInterface()

    registrationMethodLabel = qt.QLabel( 'DF Smoothing Sigma:' )

    # Create the possible registration method labels
    smooth = [1.0, 1.5, 2.0, 2.5]

    # Registration Methods Combo box
    self.__smoothComboBox = qt.QComboBox()
    self.__smoothComboBox.toolTip = "Choose the Deformation Field Smoothing Sigma"
    for i,m in enumerate(smooth):
      self.__smoothComboBox.insertItem(i, m)

    # If the smoothing parameter changes we may have to add more things to the layout
    self.__smoothComboBox.connect('currentIndexChanged(int)', self.onSmoothChanged)
    
    # Registration button
    self.__registrationButton = qt.QPushButton("Run registration")
    self.__registrationButton.toolTip = "Register the volumes with DEMONS Brain Registration."
    self.__registrationStatus = qt.QLabel('Registration Status: N/A')

    # Selector for the registered volume to use
    resultLabel = qt.QLabel('Choose registered volume or deformation field to use during quantification:')
    self.__resultVolumeSelector = slicer.qMRMLNodeComboBox()
    self.__resultVolumeSelector.toolTip = "Choose the registered volume to use during quantification (optional)."
    self.__resultVolumeSelector.nodeTypes = ['vtkMRMLScalarVolumeNode']
    self.__resultVolumeSelector.setCurrentNodeIndex(0) # Empty in the beginning
    self.__resultVolumeSelector.setMRMLScene(slicer.mrmlScene)
    self.__resultVolumeSelector.addEnabled = 0
    
    self.__resultTransformSelector = slicer.qMRMLNodeComboBox()
    self.__resultTransformSelector.toolTip = "Choose the Deformation Field to use during quantification (required)."
    #self.__resultTransformSelector.nodeTypes = ['vtkMRMLGridTransformNode']
    self.__resultVolumeSelector.nodeTypes = ['vtkMRMLScalarVolumeNode']
    self.__resultVolumeSelector.setCurrentNodeIndex(0) # Empty in the beginning
    self.__resultTransformSelector.setMRMLScene(slicer.mrmlScene)
    self.__resultTransformSelector.addEnabled = 0
    
    self.__layout.addRow(registrationMethodLabel, self.__smoothComboBox)
    self.__layout.addRow(self.__registrationButton)
    self.__layout.addRow("", qt.QWidget()) # empty row
    self.__layout.addRow(self.__registrationStatus)
    self.__layout.addRow("", qt.QWidget()) # empty row
    self.__registrationButton.connect('clicked()', self.onRegistrationRequest)
    self.__layout.addRow(resultLabel)
    self.__layout.addRow("", qt.QWidget()) # empty row
    self.__layout.addRow(self.__resultVolumeSelector)
    self.__layout.addRow(self.__resultTransformSelector)
    self.__layout.addRow("", qt.QWidget()) # empty row
    
    qt.QTimer.singleShot(0, self.killButton)


  def killButton(self):
    # hide useless button
    bl = slicer.util.findChildren(text='Quantification')
    if len(bl):
      bl[2].hide()
    

  def onEntry(self, comingFrom, transitionType):
    super(RegistrationStep, self).onEntry(comingFrom, transitionType)
    
    self.updateWidgetFromParameters(self.parameterNode())
    pNode = self.parameterNode()
    pNode.SetParameter('currentStep', self.stepid)

    qt.QTimer.singleShot(0, self.killButton)
    
    
  def onExit(self, goingTo, transitionType):
    # Nothing more because we already saved the volumes in pNode during validation
    super(RegistrationStep, self).onExit(goingTo, transitionType)

  
  def updateWidgetFromParameters(self, parameterNode):
    '''
    Update the widget according to the parameters selected by the user
    '''
    # Fill registered volume
    registeredVolumeID = parameterNode.GetParameter('registeredVolumeID')
    if registeredVolumeID != '':
      self.__resultVolumeSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(registeredVolumeID))
        
    # Fill registered transform
    registeredTransformID = parameterNode.GetParameter('registeredTransformID')
    if registeredTransformID != '':
      self.__resultTransformSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(registeredTransformID))

    # Fill smoothing sigma index
    smoothIndex = parameterNode.GetParameter('registrationSmoothIndex')
    if smoothIndex != '':
      self.__smoothComboBox.setCurrentIndex(int(smoothIndex))

 
  def validate(self, desiredBranchId):
    '''
    Must define it since we inherit from ctk.ctkWorkflowWidgetStep
    Check if there is a result from the registration (a volume or a transform).
    '''
    self.__parent.validate(desiredBranchId)

    pNode = self.parameterNode()

    # Save the registration smoothing sigma chosen
    smooth = self.__smoothComboBox.currentIndex 
    if smooth != 0:
      pNode.SetParameter('registrationSmoothIndex', str(smooth)) # Save smoothIndex as a string

    resultVolume = self.__resultVolumeSelector.currentNode()
    resultTransform = self.__resultTransformSelector.currentNode()
    if resultTransform == None:
      self.__parent.validationFailed(desiredBranchId, 'Error','Please select a deformation field to use during quantification.')

    if resultVolume != None:
      pNode.SetParameter('registeredVolumeID', resultVolume.GetID())
      # If we have already subtracted we must reset the volume
      if pNode.GetParameter('subtractedVolumeID') != '':
        pNode.SetParameter('subtractedVolumeID', '')
    
    if resultTransform != None:
      pNode.SetParameter('registeredTransformID', resultTransform.GetID())
      # If we have already subtracted we must reset the deformation field
      if pNode.GetParameter('subtractedVolumeID') != '':
        pNode.SetParameter('subtractedVolumeID', '')

    self.__parent.validationSucceeded(desiredBranchId)



  def onSmoothChanged(self):
    smoothIndex = self.__smoothComboBox.currentIndex
      

  def onRegistrationRequest(self):
    smoothIndex = self.__smoothComboBox.currentIndex
        
    pNode = self.parameterNode()
    baselineVolumeID = pNode.GetParameter('baselineVolumeID')
    followupVolumeID = pNode.GetParameter('followupVolumeID')
    
    # Create and add the new nodes to be filled during this step
    self.__registeredTransform = slicer.mrmlScene.CreateNodeByClass('vtkMRMLGridTransformNode')
    self.__registeredTransform.SetName('Register_transform')
    slicer.mrmlScene.AddNode(self.__registeredTransform)
    self.__registeredVolume = slicer.mrmlScene.CreateNodeByClass('vtkMRMLScalarVolumeNode')
    self.__registeredVolume.SetName('Register_output')
    slicer.mrmlScene.AddNode(self.__registeredVolume)
    
    parameters = {}
    
    # Demon Registration (BRAINS)
    registrationCLI = slicer.modules.brainsdemonwarp
    parameters["fixedVolume"] = baselineVolumeID
    parameters["movingVolume"] = followupVolumeID
    parameters["smoothDeformationFieldSigma"] = smoothIndex # As indicated by the user
    parameters["outputVolume"] = self.__registeredVolume
    parameters["outputDeformationFieldVolume"] = self.__registeredTransform
    parameters["interpolationMode"] = "Linear" # Default is Linear
    parameters["registrationFilterType"] = "Diffeomorphic" # Default is Diffeomorphic
    
    # Call the CLI
    self.__cliNode = None
    self.__cliNode = slicer.cli.run(registrationCLI, self.__cliNode, parameters)

    self.__cliObserverTag = self.__cliNode.AddObserver('ModifiedEvent', self.processRegistrationCompletion)
    self.__registrationStatus.setText('Wait ...')
    self.__registrationButton.setEnabled(0)
      
        
  def processRegistrationCompletion(self, node, event):
    status = node.GetStatusString()
    self.__registrationStatus.setText('Registration Status: '+status)
    if status == 'Completed':
      self.__registrationButton.setEnabled(1)
  
      pNode = self.parameterNode()
      self.setBgFgVolumes(pNode.GetParameter('baselineVolumeID'), pNode.GetParameter('followupVolumeID'))

      # Save both results in the parameterNode. Check if they exist first because not all methods fill everything.
      # Move the result selector to the new results.
      if self.__registeredTransform != None: 
        pNode.SetParameter('registeredTransformID', self.__registeredTransform.GetID())
        self.__resultTransformSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(self.__registeredTransform.GetID()))
      if self.__registeredVolume != None:  
        pNode.SetParameter('registeredVolumeID', self.__registeredVolume.GetID())
        self.__resultVolumeSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(self.__registeredVolume.GetID()))
 
    elif status == 'CompletedWithErrors':
      self.__registrationButton.setEnabled(1)
      # TODO: Can I tell exactly what happened?
      qt.QMessageBox.warning(self, 'Error: Registration', 'The registration completed with errors. Please check the inputs.')


  def setBgFgVolumes(self, bg, fg):
    appLogic = slicer.app.applicationLogic()
    selectionNode = appLogic.GetSelectionNode()
    selectionNode.SetReferenceActiveVolumeID(bg)
    selectionNode.SetReferenceSecondaryVolumeID(fg)
    appLogic.PropagateVolumeSelection()
  
