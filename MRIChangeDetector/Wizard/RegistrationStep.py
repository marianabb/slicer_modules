from __main__ import qt, ctk, vtk, slicer

from MRIChangeDetectorStep import *


class RegistrationStep(MRIChangeDetectorStep):
  def __init__(self, stepid):
    self.initialize(stepid)
    self.setName( '2. Select registration method' )
    self.setDescription( 'Select the registration method to be used when aligning the baseline with the follow-up volume.' )
    
    self.__parent = super(RegistrationStep, self)

    # Define a clean GroupBox for specific registration method settings
    self.__regGroupBox = None
    
    # Transform generated by the registration to go from the follow-up to the baseline volume
    self.__registeredTransform = None
    # Volume generated by the registration (follow-up volume registered to baseline volume)
    self.__registeredVolume = None

    # Fiducial lists for fiducial registration
    self.__baseFiducialList = None
    self.__followFiducialList = None

    qt.QTimer.singleShot(0, self.killButton)


  def createUserInterface(self):
    '''
    The interface allows choosing a registration method and applying it on the already chosen volumes.
    Alternatively the user can choose an already registered volume.
    '''

    self.__layout = self.__parent.createUserInterface()

    registrationMethodLabel = qt.QLabel( 'Registration method:' )

    # Create the possible registration method labels
    methods = ['Choose a method', 'Affine Registration', 'Demon Registration (BRAINS)', 'BSpline deformable registration', 'Fiducial Registration']

    # Registration Methods Combo box
    self.__methodsComboBox = qt.QComboBox()
    self.__methodsComboBox.toolTip = "Choose the preferred registration method"
    for i,m in enumerate(methods):
      self.__methodsComboBox.insertItem(i, m)

    # If the method changes we may have to add more things to the layout
    self.__methodsComboBox.connect('currentIndexChanged(int)', self.onMethodChanged)
    
    # Registration button
    self.__registrationButton = qt.QPushButton("Run registration")
    self.__registrationButton.toolTip = "Register the volumes."
    self.__registrationStatus = qt.QLabel('Registration Status: N/A')

    # Selector for the registered volume to use
    resultLabel = qt.QLabel('Choose registered volume or transform to use during quantification:')
    self.__resultVolumeSelector = slicer.qMRMLNodeComboBox()
    self.__resultVolumeSelector.toolTip = "Choose the registered volume to use during quantification."
    self.__resultVolumeSelector.nodeTypes = ['vtkMRMLScalarVolumeNode']
    self.__resultVolumeSelector.setCurrentNodeIndex(0) # Empty in the beginning
    self.__resultVolumeSelector.setMRMLScene(slicer.mrmlScene)
    self.__resultVolumeSelector.addEnabled = 0
    
    self.__resultTransformSelector = slicer.qMRMLNodeComboBox()
    self.__resultTransformSelector.toolTip = "Choose the registered transform to use during quantification."
    self.__resultTransformSelector.nodeTypes = ['vtkMRMLLinearTransformNode'] # TODO maybe the transform is not always linear
    self.__resultVolumeSelector.setCurrentNodeIndex(0) # Empty in the beginning
    self.__resultTransformSelector.setMRMLScene(slicer.mrmlScene)
    self.__resultTransformSelector.addEnabled = 0
    
    self.__layout.addRow(registrationMethodLabel, self.__methodsComboBox)
    self.__layout.addRow(self.__registrationButton)
    self.__layout.addRow("", qt.QWidget()) # empty row
    self.__layout.addRow(self.__registrationStatus)
    self.__layout.addRow("", qt.QWidget()) # empty row
    self.__registrationButton.connect('clicked()', self.onRegistrationRequest)
    self.__layout.addRow(resultLabel)
    self.__layout.addRow("", qt.QWidget()) # empty row
    self.__layout.addRow(self.__resultVolumeSelector)
    self.__layout.addRow(self.__resultTransformSelector)
    self.__layout.addRow("", qt.QWidget()) # empty row
    
    qt.QTimer.singleShot(0, self.killButton)


  def killButton(self):
    # hide useless button
    bl = slicer.util.findChildren(text='Quantification')
    if len(bl):
      bl[2].hide()
    

  def onEntry(self, comingFrom, transitionType):
    super(RegistrationStep, self).onEntry(comingFrom, transitionType)
    
    self.updateWidgetFromParameters(self.parameterNode())
    pNode = self.parameterNode()
    pNode.SetParameter('currentStep', self.stepid)

    qt.QTimer.singleShot(0, self.killButton)
    
    
  def onExit(self, goingTo, transitionType):
    # Nothing more because we already saved the volumes in pNode during validation
    super(RegistrationStep, self).onExit(goingTo, transitionType)

  
  def updateWidgetFromParameters(self, parameterNode):
    '''
    Update the widget according to the parameters selected by the user
    '''
    # Fill registered volume
    registeredVolumeID = parameterNode.GetParameter('registeredVolumeID')
    if registeredVolumeID != '':
      self.__resultVolumeSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(registeredVolumeID))
        
    # Fill registered transform
    registeredTransformID = parameterNode.GetParameter('registeredTransformID')
    if registeredTransformID != '':
      self.__resultTransformSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(registeredTransformID))

    # Fill method index
    methodIndex = parameterNode.GetParameter('registrationMethodIndex')
    if methodIndex != '':
      self.__methodsComboBox.setCurrentIndex(int(methodIndex))

      # If fiducial registration fill in fiducial lists
      if methodIndex == 4:
        baseFiducialsID = parameterNode.GetParameter('baseFiducialsID')
        self.__baseFiducialsSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(baseFiducialsID))
        followFiducialsID = parameterNode.GetParameter('followFiducialsID')
        self.__followFiducialsSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(followFiducialsID))

      
  def validate(self, desiredBranchId):
    '''
    Must define it since we inherit from ctk.ctkWorkflowWidgetStep
    Check if there is a result from the registration (a volume or a transform).
    '''
    self.__parent.validate(desiredBranchId)

    pNode = self.parameterNode()

    # Save the registration method chosen
    method = self.__methodsComboBox.currentIndex 
    if method != 0:
      pNode.SetParameter('registrationMethodIndex', str(method)) # Save methodIndex as a string

    resultVolume = self.__resultVolumeSelector.currentNode()
    resultTransform = self.__resultTransformSelector.currentNode()
    if resultVolume == None and resultTransform == None:
      self.__parent.validationFailed(desiredBranchId, 'Error','Please select a registered volume or transform to use during quantification.')

    if resultVolume != None:
      pNode.SetParameter('registeredVolumeID', resultVolume.GetID())
      # If we have already subtracted we must reset the volume
      if pNode.GetParameter('subtractedVolumeID') != '':
        pNode.SetParameter('subtractedVolumeID', '')
    
    if resultTransform != None:
      pNode.SetParameter('registeredTransformID', resultTransform.GetID())
      # If we have already subtracted we must reset the volume
      if pNode.GetParameter('subtractedVolumeID') != '':
        pNode.SetParameter('subtractedVolumeID', '')

    self.__parent.validationSucceeded(desiredBranchId)



  def onMethodChanged(self):
    methodIndex = self.__methodsComboBox.currentIndex
    
    if methodIndex == 4: # Fiducial registration
      # Only create the box if it doesn't exist
      if self.__regGroupBox == None:
        self.__regGroupBox = qt.QGroupBox()
        self.__regGroupBox.setTitle('Registration method specific settings')
        self.__layout.addRow(self.__regGroupBox)
        regGroupLayout = qt.QFormLayout(self.__regGroupBox) # TODO needs to be a class att?

        baseFiducialsLabel = qt.QLabel('Fixed landmarks:')
        self.__baseFiducialsSelector = slicer.qMRMLNodeComboBox()
        self.__baseFiducialsSelector.toolTip = "Ordered list of landmarks in the fixed image"
        self.__baseFiducialsSelector.nodeTypes = ['vtkMRMLAnnotationHierarchyNode']
        self.__baseFiducialsSelector.setMRMLScene(slicer.mrmlScene)
        self.__baseFiducialsSelector.addEnabled = 0 # The list must be created already
        regGroupLayout.addRow(baseFiducialsLabel, self.__baseFiducialsSelector)

        followFiducialsLabel = qt.QLabel('Moving landmarks:')
        self.__followFiducialsSelector = slicer.qMRMLNodeComboBox()
        self.__followFiducialsSelector.toolTip = "Ordered list of landmarks in the moving image"
        self.__followFiducialsSelector.nodeTypes = ['vtkMRMLAnnotationHierarchyNode']
        self.__followFiducialsSelector.setMRMLScene(slicer.mrmlScene)
        self.__followFiducialsSelector.addEnabled = 0 # The list must be created already
        regGroupLayout.addRow(followFiducialsLabel, self.__followFiducialsSelector)
      else:
        self.__regGroupBox.setVisible(True)
        
    else:
      # Make fiducial box invisible (if it exists)
      if self.__regGroupBox != None:
        self.__regGroupBox.setVisible(False)
      

  def onRegistrationRequest(self):
    methodIndex = self.__methodsComboBox.currentIndex
    # Validate the inputs
    if self.validateRegistrationInput(methodIndex):
    
      pNode = self.parameterNode()
      baselineVolumeID = pNode.GetParameter('baselineVolumeID')
      followupVolumeID = pNode.GetParameter('followupVolumeID')

      # Create and add the new nodes to be filled during this step TODO: Maybe create them depending on method
      self.__registeredTransform = slicer.mrmlScene.CreateNodeByClass('vtkMRMLLinearTransformNode')
      self.__registeredTransform.SetName('Register_transform')
      slicer.mrmlScene.AddNode(self.__registeredTransform)
      self.__registeredVolume = slicer.mrmlScene.CreateNodeByClass('vtkMRMLScalarVolumeNode')
      self.__registeredVolume.SetName('Register_output')
      slicer.mrmlScene.AddNode(self.__registeredVolume)

      parameters = {}
      registrationCLI = None
    
      # Choose the right registration method according to 'methodLabel' and fill its parameters
      if methodIndex == 1: # Affine Registration
        registrationCLI = slicer.modules.affineregistration
        parameters["OutputTransform"] = self.__registeredTransform.GetID()
        parameters["ResampledImageFileName"] = self.__registeredVolume.GetID()
        parameters["FixedImageFileName"] = baselineVolumeID
        parameters["MovingImageFileName"] = followupVolumeID
      elif methodIndex == 2: # BSpline deformable registration
        registrationCLI = slicer.modules.bsplinedeformableregistration
        parameters["Iterations"] = 20 # Default is 20
        parameters["GridSize"] = 5 # Default is 5
        parameters["HistogramBins"] = 100 # Default is 100
        parameters["SpatialSamples"] = 50000 # Default is 50000
        parameters["FixedImageFileName"] = baselineVolumeID
        parameters["MovingImageFileName"] = followupVolumeID
        parameters["OutputTransform"] = self.__registeredTransform.GetID()
        parameters["ResampledImageFileName"] = self.__registeredVolume.GetID()
      elif methodIndex == 3: # Demon Registration (BRAINS)
        registrationCLI = slicer.modules.brainsdemonwarp
        parameters["fixedVolume"] = baselineVolumeID
        parameters["movingVolume"] = followupVolumeID
        parameters["outputVolume"] = self.__registeredVolume
        # TODO in this method the output transform is not linear, it's a GridTransform
        parameters["interpolationMode"] = "Linear" # Default is Linear
        parameters["registrationFilterType"] = "Diffeomorphic" # Default is Diffeomorphic
      #elif methodIndex == 4: # Fiducial Registration #TODO: Maybe add later
      #  registrationCLI = slicer.modules.fiducialregistration
      #  parameters["fixedLandmarks"] = self.__baseFiducialList.GetID()
      #  parameters["movingLandmarks"] = self.__followFiducialList.GetID()
      #  parameters["saveTransform"] = self.__registeredTransform.GetID()
      #  parameters["transformType"] = "Rigid" # Default is Rigid
      else: # Default to Affine Registration
        registrationCLI = slicer.modules.affineregistration
        parameters["OutputTransform"] = self.__registeredTransform.GetID()
        parameters["ResampledImageFileName"] = self.__registeredVolume.GetID()
        parameters["FixedImageFileName"] = baselineVolumeID
        parameters["MovingImageFileName"] = followupVolumeID

      # Call the CLI
      self.__cliNode = None
      self.__cliNode = slicer.cli.run(registrationCLI, self.__cliNode, parameters)

      self.__cliObserverTag = self.__cliNode.AddObserver('ModifiedEvent', self.processRegistrationCompletion)
      self.__registrationStatus.setText('Wait ...')
      self.__registrationButton.setEnabled(0)
      
    else:
      # Input validation was unsuccessful. Show a message depending on the method
      if methodIndex == 4:
        qt.QMessageBox.warning(self, 'Error: Fiducial Registration', 'Please select valid and disctinct lists of landmarks.')
      else:
        qt.QMessageBox.warning(self, 'Error: Registration', 'The registration inputs provided are incomplete or wrong.')
      

  def validateRegistrationInput(self, method):
    # Fiducial registration requires two lists of landmarks
    if method == 4:
      self.__baseFiducialList = self.__baseFiducialsSelector.currentNode()
      self.__followFiducialList = self.__followFiducialsSelector.currentNode()
      if self.__baseFiducialList == None or self.__followFiducialList == None:
        return False
      else:
        # We have fiducials. Save them in the parameter node.
        baseFID = self.__baseFiducialList.GetID()
        followFID = self.__followFiducialList.GetID()

        if baseFID != '' and followFID != '' and baseFID != followFID:
          pNode = self.parameterNode()
          pNode.SetParameter('baseFiducialsID', baseFID)
          pNode.SetParameter('followFiducialsID', followFID)
        else:
          return False

    # If you made it this far, everything is fine
    return True
        

    
  def processRegistrationCompletion(self, node, event):
    status = node.GetStatusString()
    self.__registrationStatus.setText('Registration Status: '+status)
    if status == 'Completed':
      self.__registrationButton.setEnabled(1)
  
      pNode = self.parameterNode()
      # Apply the generated transform on the follow-up node. TODO: Do I really want this?
      #if self.__registeredTransform != None:
      #  followupNode = slicer.mrmlScene.GetNodeByID(pNode.GetParameter('followupVolumeID'))
      #  followupNode.SetAndObserveTransformNodeID(self.__registeredTransform.GetID())
      
      self.setBgFgVolumes(pNode.GetParameter('baselineVolumeID'), pNode.GetParameter('followupVolumeID'))

      # Save both results in the parameterNode. Check if they exist first because not all methods fill everything.
      # Move the result selector to the new results.
      if self.__registeredTransform != None: 
        pNode.SetParameter('registeredTransformID', self.__registeredTransform.GetID())
        self.__resultTransformSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(self.__registeredTransform.GetID()))
      if self.__registeredVolume != None:  
        pNode.SetParameter('registeredVolumeID', self.__registeredVolume.GetID())
        self.__resultVolumeSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(self.__registeredVolume.GetID()))

      # If the method was fiducial registration, save also the fiducial lists
      if self.__baseFiducialList != None and self.__followFiducialList != None:
        pNode.SetParameter('baseFiducialsID', self.__baseFiducialList.GetID())
        pNode.SetParameter('followFiducialsID', self.__followFiducialList.GetID())
        
    elif status == 'CompletedWithErrors':
      self.__registrationButton.setEnabled(1)
      # TODO: Can I tell exactly what happened?
      qt.QMessageBox.warning(self, 'Error: Registration', 'The registration completed with errors. Please check the inputs.')


  def setBgFgVolumes(self, bg, fg):
    appLogic = slicer.app.applicationLogic()
    selectionNode = appLogic.GetSelectionNode()
    selectionNode.SetReferenceActiveVolumeID(bg)
    selectionNode.SetReferenceSecondaryVolumeID(fg)
    appLogic.PropagateVolumeSelection()
  
