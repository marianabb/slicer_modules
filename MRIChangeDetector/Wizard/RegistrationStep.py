from __main__ import qt, ctk, vtk, slicer

from MRIChangeDetectorStep import *


class RegistrationStep(MRIChangeDetectorStep):
  def __init__(self, stepid):
    self.initialize(stepid)
    self.setName( '2. Select registration method' )
    self.setDescription( 'Select the registration method to be used when aligning the baseline with the follow-up volume.' )
    
    self.__parent = super(RegistrationStep, self)

    # Define a clean GroupBox for specific registration method settings
    self.__regGroupBox = None
    
    # Transform generated by the registration to go from the follow-up to the baseline volume
    self.__followupTransform = None
    # Volume generated by the registration (follow-up volume registered to baseline volume)
    self.__followupRegisteredVolume = None

    # Fiducial lists for fiducial registration
    self.__baseFiducialList = None
    self.__followFiducialList = None

    qt.QTimer.singleShot(0, self.killButton)


  def createUserInterface(self):
    '''
    The interface allows choosing a registration method and applying it on the already chosen volumes.
    TODO: Alternatively the user can choose an already registered volume.
    '''

    self.__layout = self.__parent.createUserInterface()

    registrationMethodLabel = qt.QLabel( 'Registration method:' )

    # Create the possible registration method labels
    methods = ['Choose a method', 'General Registration (BRAINS)', 'Demon Registration (BRAINS)', 'BSpline deformable registration', 'Fiducial Registration']

    # Registration Methods Combo box
    self.__methodsComboBox = qt.QComboBox()
    self.__methodsComboBox.toolTip = "Choose the preferred registration method"
    for i,m in enumerate(methods):
      self.__methodsComboBox.insertItem(i, m)

    # If the method changes we may have to add more things to the layout
    self.__methodsComboBox.connect('currentIndexChanged(int)', self.onMethodChanged)
    
    # Registration button
    self.__registrationButton = qt.QPushButton("Run registration")
    self.__registrationButton.toolTip = "Register the volumes."
    self.__registrationStatus = qt.QLabel('Registration Status: N/A')

    
    self.__layout.addRow(registrationMethodLabel, self.__methodsComboBox)
    self.__layout.addRow(self.__registrationButton)
    self.__layout.addRow("", qt.QWidget()) # empty row
    self.__layout.addRow(self.__registrationStatus)
    self.__layout.addRow("", qt.QWidget()) # empty row
    self.__registrationButton.connect('clicked()', self.onRegistrationRequest)

    qt.QTimer.singleShot(0, self.killButton)


  def killButton(self):
    # hide useless button
    bl = slicer.util.findChildren(text='Quantification')
    if len(bl):
      bl[2].hide()
    

  def onEntry(self, comingFrom, transitionType):
    super(RegistrationStep, self).onEntry(comingFrom, transitionType)
    
    self.updateWidgetFromParameters(self.parameterNode())
    pNode = self.parameterNode()
    pNode.SetParameter('currentStep', self.stepid)

    qt.QTimer.singleShot(0, self.killButton)
    
    
  def onExit(self, goingTo, transitionType):
    if goingTo.id() != 'Quantification':
      return

    # Nothing more because we already saved the volumes in pNode during validation
    super(RegistrationStep, self).onExit(goingTo, transitionType)

  
  def updateWidgetFromParameters(self, parameterNode):
    '''
    Update the widget according to the parameters selected by the user
    '''
    methodIndex = parameterNode.GetParameter('registrationMethodIndex')
    if methodIndex != '':
      self.__methodsComboBox.setCurrentIndex(methodIndex)

      # If fiducial registration fill in fiducial lists
      if methodIndex == 4:
        baseFiducialsID = pNode.GetParameter('baseFiducialsID')
        self.__baseFiducialsSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(baseFiducialsID))
        followFiducialsID = pNode.GetParameter('followFiducialsID')
        self.__followFiducialsSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(followFiducialsID))

      
  def validate(self, desiredBranchId):
    '''
    Must define it since we inherit from ctk.ctkWorkflowWidgetStep
    Check if there is a result from the registration (a volume or a transform).
    '''
    self.__parent.validate(desiredBranchId)

    # Save the registration method chosen
    method = self.__methodsComboBox.currentIndex
 
    if method != 0:
      pNode = self.parameterNode()
      pNode.SetParameter('registrationMethodIndex', str(method)) # Save methodIndex as a string

    if self.__followupTransform == None or self.__followupRegisteredVolume == None:
      self.__parent.validationFailed(desiredBranchId, 'Error','Registration output is needed.')
    
    self.__parent.validationSucceeded(desiredBranchId)



  def onMethodChanged(self):
    methodIndex = self.__methodsComboBox.currentIndex
    
    if methodIndex == 4: # Fiducial registration
      # Only create the box if it doesn't exist
      if self.__regGroupBox == None:
        self.__regGroupBox = qt.QGroupBox()
        self.__regGroupBox.setTitle('Registration method specific settings')
        self.__layout.addRow(self.__regGroupBox)
        regGroupLayout = qt.QFormLayout(self.__regGroupBox) # TODO needs to be a class att?

        baseFiducialsLabel = qt.QLabel('Fixed landmarks:')
        self.__baseFiducialsSelector = slicer.qMRMLNodeComboBox()
        self.__baseFiducialsSelector.toolTip = "Ordered list of landmarks in the fixed image"
        self.__baseFiducialsSelector.nodeTypes = ['vtkMRMLAnnotationHierarchyNode']
        self.__baseFiducialsSelector.setMRMLScene(slicer.mrmlScene)
        self.__baseFiducialsSelector.addEnabled = 0 # The list must be created already
        regGroupLayout.addRow(baseFiducialsLabel, self.__baseFiducialsSelector)

        followFiducialsLabel = qt.QLabel('Moving landmarks:')
        self.__followFiducialsSelector = slicer.qMRMLNodeComboBox()
        self.__followFiducialsSelector.toolTip = "Ordered list of landmarks in the moving image"
        self.__followFiducialsSelector.nodeTypes = ['vtkMRMLAnnotationHierarchyNode']
        self.__followFiducialsSelector.setMRMLScene(slicer.mrmlScene)
        self.__followFiducialsSelector.addEnabled = 0 # The list must be created already
        regGroupLayout.addRow(followFiducialsLabel, self.__followFiducialsSelector)
      else:
        self.__regGroupBox.setVisible(True)
        
    else:
      # Make fiducial box invisible (if it exists)
      if self.__regGroupBox != None:
        self.__regGroupBox.setVisible(False)
      

  def onRegistrationRequest(self):
    methodIndex = self.__methodsComboBox.currentIndex
    # Validate the inputs
    if self.validateRegistrationInput(methodIndex):
    
      pNode = self.parameterNode()
      baselineVolumeID = pNode.GetParameter('baselineVolumeID')
      followupVolumeID = pNode.GetParameter('followupVolumeID')

      # Create and add the new nodes to be filled during this step TODO: Maybe create them depending on method
      self.__followupTransform = slicer.mrmlScene.CreateNodeByClass('vtkMRMLLinearTransformNode')
      slicer.mrmlScene.AddNode(self.__followupTransform)
      self.__followupRegisteredVolume = slicer.mrmlScene.CreateNodeByClass('vtkMRMLScalarVolumeNode')
      slicer.mrmlScene.AddNode(self.__followupRegisteredVolume)

      parameters = {}
      registrationCLI = None
    
      # Choose the right registration method according to 'methodLabel' and fill its parameters
      if methodIndex == 1: # General Registration (BRAINS)
        registrationCLI = slicer.modules.brainsfit
        parameters["linearTransform"] = self.__followupTransform.GetID()
        parameters["outputVolume"] = self.__followupRegisteredVolume.GetID()
        parameters["fixedVolume"] = baselineVolumeID
        parameters["movingVolume"] = followupVolumeID
        parameters["initializeTransformMode"] = "useCenterOfHeadAlign"
        parameters["useRigid"] = True
        parameters["useScaleVersor3D"] = True
        parameters["useScaleSkewVersor3D"] = True
        parameters["useAffine"] = True
      elif methodIndex == 2: # Demon Registration (BRAINS)
        registrationCLI = slicer.modules.brainsdemonwarp
        parameters["fixedVolume"] = baselineVolumeID
        parameters["movingVolume"] = followupVolumeID
        parameters["outputVolume"] = self.__followupRegisteredVolume
        # TODO in this method the output transform is not linear, it's a GridTransform
        parameters["interpolationMode"] = "Linear" # Default is Linear
        parameters["registrationFilterType"] = "Diffeomorphic" # Default is Diffeomorphic
      elif methodIndex == 3: # BSpline deformable registration
        registrationCLI = slicer.modules.bsplinedeformableregistration
        parameters["Iterations"] = 20 # Default is 20
        parameters["GridSize"] = 5 # Default is 5
        parameters["HistogramBins"] = 100 # Default is 100
        parameters["SpatialSamples"] = 50000 # Default is 50000
        parameters["FixedImageFileName"] = baselineVolumeID
        parameters["MovingImageFileName"] = followupVolumeID
        parameters["OutputTransform"] = self.__followupTransform.GetID()
        parameters["ResampledImageFileName"] = self.__followupRegisteredVolume.GetID()
      elif methodIndex == 4: # Fiducial Registration
        registrationCLI = slicer.modules.fiducialregistration
        parameters["fixedLandmarks"] = self.__baseFiducialList.GetID()
        parameters["movingLandmarks"] = self.__followFiducialList.GetID()
        parameters["saveTransform"] = self.__followupTransform.GetID()
        parameters["transformType"] = "Rigid" # Default is Rigid
      else: # Default to General Registration (BRAINS)
        registrationCLI = slicer.modules.brainsfit
        parameters["linearTransform"] = self.__followupTransform.GetID()
        parameters["outputVolume"] = self.__followupRegisteredVolume.GetID()
        parameters["fixedVolume"] = baselineVolumeID
        parameters["movingVolume"] = followupVolumeID
        parameters["initializeTransformMode"] = "useCenterOfHeadAlign"
        parameters["useRigid"] = True
        parameters["useScaleVersor3D"] = True
        parameters["useScaleSkewVersor3D"] = True
        parameters["useAffine"] = True

      # Call the CLI
      self.__cliNode = None
      self.__cliNode = slicer.cli.run(registrationCLI, self.__cliNode, parameters)

      self.__cliObserverTag = self.__cliNode.AddObserver('ModifiedEvent', self.processRegistrationCompletion)
      self.__registrationStatus.setText('Wait ...')
      self.__registrationButton.setEnabled(0)
      
    else:
      # Input validation was unsuccessful. Show a message depending on the method
      if methodIndex == 4:
        qt.QMessageBox.warning(self, 'Error: Fiducial Registration', 'Please select valid and disctinct lists of landmarks.')
      else:
        qt.QMessageBox.warning(self, 'Error: Registration', 'The registration inputs provided are incomplete or wrong.')
      

  def validateRegistrationInput(self, method):
    # Fiducial registration requires two lists of landmarks
    if method == 4:
      self.__baseFiducialList = self.__baseFiducialsSelector.currentNode()
      self.__followFiducialList = self.__followFiducialsSelector.currentNode()
      if self.__baseFiducialList == None or self.__followFiducialList == None:
        return False
      else:
        # We have fiducials. Save them in the parameter node.
        baseFID = self.__baseFiducialList.GetID()
        followFID = self.__followFiducialList.GetID()

        if baseFID != '' and followFID != '' and baseFID != followFID:
          pNode = self.parameterNode()
          pNode.SetParameter('baseFiducialsID', baseFID)
          pNode.SetParameter('followFiducialsID', followFID)
        else:
          return False

    # If you made it this far, everything is fine
    return True
        

    
  def processRegistrationCompletion(self, node, event):
    status = node.GetStatusString()
    self.__registrationStatus.setText('Registration Status: '+status)
    if status == 'Completed':
      self.__registrationButton.setEnabled(1)
  
      pNode = self.parameterNode()
      # Apply the generated transform on the follow-up node. TODO: Do I really want this?
      #if self.__followupTransform != None:
      #  followupNode = slicer.mrmlScene.GetNodeByID(pNode.GetParameter('followupVolumeID'))
      #  followupNode.SetAndObserveTransformNodeID(self.__followupTransform.GetID())
      
      self.setBgFgVolumes(pNode.GetParameter('baselineVolumeID'), pNode.GetParameter('followupVolumeID'))

      # Save both results in the parameterNode. Check if they exist first because not all methods fill everything.
      if self.__followupTransform != None: 
        pNode.SetParameter('followupTransformID', self.__followupTransform.GetID())
      if self.__followupRegisteredVolume != None:  
        pNode.SetParameter('followupRegisteredVolumeID', self.__followupRegisteredVolume.GetID())

      # If the method was fiducial registration, save also the fiducial lists
      if self.__baseFiducialList != None and self.__followFiducialList != None:
        pNode.SetParameter('baseFiducialsID', self.__baseFiducialList.GetID())
        pNode.SetParameter('followFiducialsID', self.__followFiducialList.GetID())
        
    elif status == 'CompletedWithErrors':
      self.__registrationButton.setEnabled(1)
      # TODO: Can I tell exactly what happened?
      qt.QMessageBox.warning(self, 'Error: Registration', 'The registration completed with errors. Please check the inputs.')


  def setBgFgVolumes(self, bg, fg):
    appLogic = slicer.app.applicationLogic()
    selectionNode = appLogic.GetSelectionNode()
    selectionNode.SetReferenceActiveVolumeID(bg)
    selectionNode.SetReferenceSecondaryVolumeID(fg)
    appLogic.PropagateVolumeSelection()
