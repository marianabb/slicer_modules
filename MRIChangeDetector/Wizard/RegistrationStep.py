from __main__ import qt, ctk, vtk, slicer

from MRIChangeDetectorStep import *


class RegistrationStep(MRIChangeDetectorStep):
  def __init__(self, stepid):
    self.initialize(stepid)
    self.setName( '2. Select registration method' )
    self.setDescription( 'Select the registration method to be used when aligning the baseline with the follow-up volume.' )
    
    self.__parent = super(RegistrationStep, self)

    # Transform generated by the registration to go from the follow-up to the baseline volume
    self.__followupTransform = None
    # Volume generated by the registration (follow-up volume registered to baseline volume)
    self.__followupRegisteredVolume = None


  def createUserInterface(self):
    '''
    The interface allows choosing a registration method and applying it on the already chosen volumes.
    TODO: Alternatively the user can choose an already registered volume.
    '''

    self.__layout = self.__parent.createUserInterface()

    registrationMethodLabel = qt.QLabel( 'Registration method:' )

    # Create the possible registration method labels
    methods = ['Choose a method', 'General Registration (BRAINS)', 'Demon Registration (BRAINS)', 'BSpline deformable registration']

    # Registration Methods Combo box
    self.__methodsComboBox = qt.QComboBox()
    self.__methodsComboBox.toolTip = "Choose the preferred registration method"
    for i,m in enumerate(methods):
      self.__methodsComboBox.insertItem(i, m)
    
    
    # Registration button
    self.__registrationButton = qt.QPushButton("Run registration")
    self.__registrationButton.toolTip = "Register the volumes."
    self.__registrationStatus = qt.QLabel('Registration Status: N/A')

    
    self.__layout.addRow(registrationMethodLabel, self.__methodsComboBox)
    self.__layout.addRow(self.__registrationButton)
    self.__layout.addRow("", qt.QWidget()) # empty row
    self.__layout.addRow(self.__registrationStatus)
    self.__registrationButton.connect('clicked()', self.onRegistrationRequest)

    qt.QTimer.singleShot(0, self.killButton)


  def killButton(self):
    # hide useless button
    bl = slicer.util.findChildren(text='Registration')
    if len(bl):
      bl[3].hide()
    

  def onEntry(self, comingFrom, transitionType):
    super(RegistrationStep, self).onEntry(comingFrom, transitionType)
    
    self.updateWidgetFromParameters(self.parameterNode())
    pNode = self.parameterNode()
    pNode.SetParameter('currentStep', self.stepid)

    qt.QTimer.singleShot(0, self.killButton)
    
    
  def onExit(self, goingTo, transitionType):
    if goingTo.id() != 'Quantification':
      return

    # Nothing more because we already saved the volumes in pNode during validation
    super(SelectVolumesStep, self).onExit(goingTo, transitionType)

  
  def updateWidgetFromParameters(self, parameterNode):
    '''
    Update the widget according to the parameters selected by the user
    '''
    methodIndex = parameterNode.GetParameter('registrationMethodIndex')
    if methodIndex != '':
      self.__methodsComboBox.setCurrentIndex(methodIndex)

      
  def validate(self, desiredBranchId):
    '''
    Must define it since we inherit from ctk.ctkWorkflowWidgetStep
    Check if the registration method has been chosen.
    '''
    self.__parent.validate(desiredBranchId)

    # Check that the selector is not empty
    method = self.__methodsComboBox.currentIndex

    if method != 0:
      pNode = self.parameterNode()
      pNode.SetParameter('registrationMethodIndex', method) # TODO works?
      self.__parent.validationSucceeded(desiredBranchId)
    else:
      self.__parent.validationFailed(desiredBranchId, 'Error','Please select a registration method!')


  def onRegistrationRequest(self):
    pNode = self.parameterNode()
    baselineVolumeID = pNode.GetParameter('baselineVolumeID')
    followupVolumeID = pNode.GetParameter('followupVolumeID')
    methodIndex = pNode.GetParameter('registrationMethodIndex')

    # Create and add the new nodes to be filled during this step
    self.__followupTransform = slicer.mrmlScene.CreateNodeByClass('vtkMRMLLinearTransformNode')
    slicer.mrmlScene.AddNode(self.__followupTransform)
    self.__followupRegisteredVolume = slicer.mrmlScene.CreateNodeByClass('vtkMRMLScalarVolumeNode')
    slicer.mrmlScene.AddNode(self.__followupRegisteredVolume)

    parameters = {}
    registrationCLI = None
    
    # Choose the right registration method according to 'methodLabel' and fill its parameters
    parameters["linearTransform"] = self.__followupTransform.GetID()
    parameters["outputVolume"] = self.__followupRegisteredVolume.GetID()

    if methodIndex == 0: # General Registration (BRAINS)
      registrationCLI = slicer.modules.brainsfit
      parameters["fixedVolume"] = baselineVolumeID
      parameters["movingVolume"] = followupVolumeID
      parameters["initializeTransformMode"] = "useCenterOfHeadAlign"
      parameters["useRigid"] = True
      parameters["useScaleVersor3D"] = True
      parameters["useScaleSkewVersor3D"] = True
      parameters["useAffine"] = True
    # TODO: Add more methods
    else: # Default to General Registration (BRAINS)
      registrationCLI = slicer.modules.brainsfit
      parameters["fixedVolume"] = baselineVolumeID
      parameters["movingVolume"] = followupVolumeID
      parameters["initializeTransformMode"] = "useCenterOfHeadAlign"
      parameters["useRigid"] = True
      parameters["useScaleVersor3D"] = True
      parameters["useScaleSkewVersor3D"] = True
      parameters["useAffine"] = True

    # Call the CLI
    self.__cliNode = None
    self.__cliNode = slicer.cli.run(registrationCLI, self.__cliNode, parameters)

    self.__cliObserverTag = self.__cliNode.AddObserver('ModifiedEvent', self.processRegistrationCompletion)
    self.__registrationStatus.setText('Wait ...')
    self.__registrationButton.setEnabled(0)

    
  def processRegistrationCompletion(self, node, event):
    status = node.GetStatusString()
    self.__registrationStatus.setText('Registration Status: '+status)
    if status == 'Completed':
      self.__registrationButton.setEnabled(1)
  
      pNode = self.parameterNode()
      # Apply the generated transform on the follow-up node. TODO: Do I really want this?
      followupNode = slicer.mrmlScene.GetNodeByID(pNode.GetParameter('followupVolumeID'))
      followupNode.SetAndObserveTransformNodeID(self.__followupTransform.GetID())
      
      self.setBgFgVolumes(pNode.GetParameter('baselineVolumeID'), pNode.GetParameter('followupVolumeID'))

      # Save both results in the parameterNode. TODO: I am probably repeating myself by saving the transform and also the new volume
      pNode.SetParameter('followupTransformID', self.__followupTransform.GetID())
      pNode.SetParameter('followupRegisteredVolumeID', self.__followupRegisteredVolume.GetID())


  def setBgFgVolumes(self, bg, fg):
    appLogic = slicer.app.applicationLogic()
    selectionNode = appLogic.GetSelectionNode()
    selectionNode.SetReferenceActiveVolumeID(bg)
    selectionNode.SetReferenceSecondaryVolumeID(fg)
    appLogic.PropagateVolumeSelection()